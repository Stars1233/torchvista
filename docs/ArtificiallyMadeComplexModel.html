<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <style>
            html, body {
                height: 100%;
                margin: 0;
                font-family: monospace;
            }

            .container {
            display: flex;
                flex-direction: column;
                height: 100vh;
            }

            .left-column {
                display: flex;
                flex-direction: row;
                max-height: 40vh;
            }

            .code-box {
                flex: 1.5;
                height: 100%;
                background-color: #f5f5f5;
                padding: 16px;
                overflow: auto;
                border-right: 1px solid #ccc;
                word-wrap: break-word;
                border-bottom: none;
            }

            .error-box {
                flex: 1;
                height: 100%;
                background-color: #f5f5f5;
                padding: 16px;
                overflow: auto;
                color: red;
                font-family: monospace;
                box-shadow: inset 0 2px 4px rgba(0,0,0,0.1);
            }
            .code-box-header {
                font-weight: bold;
                margin-bottom: 10px;
                padding-bottom: 5px;
                border-bottom: 1px solid #cccccc;
                color: #333;
                font-size: large;
            }

            .error-box-header {
                font-weight: bold;
                margin-bottom: 10px;
                padding-bottom: 5px;
                border-bottom: 1px solid #000000;
                color: #333;
                font-size: large;
            }

            .graph-box-header {
                font-weight: bold;
                margin-bottom: 10px;
                padding-bottom: 5px;
                border-bottom: 1px solid #000000;
                color: #333;
                font-size: large;
            }

            /* Added for syntax highlighting */
            .code-box pre {
                margin: 0;
                padding: 0;
            }

            .code-box code {
                font-family: monospace;
            }

            .graph-view {
                height: 60vh;
                overflow: hidden;
                padding: 16px;
                background-color: #ffffff;
            }
            #graph {
                width: 100%;
                height: 100%;
            }
            .node rect {
                stroke: #333;
                fill: #fff;
            }
            text.node-label {
                font-family: "'Roboto', sans-serif";
                cursor: default;
                user-select: none;
            }
            text.type-indicator {
                font-family: "'Roboto', sans-serif";
                cursor: default;
                user-select: none;
            }
            text.collapse-icon {
                font-family: "'Roboto', sans-serif";
                font-size: 14px
                cursor: default;
                user-select: none;
            }
            .edge {
                stroke: #333333;
                fill: none;
            }
            .node rect.input { fill: #FF9AFF; }
            .node rect.constant { fill: rgb(235 235 235); }

            .node rect.output { fill: #FF9AFF; }
            .node rect.failed { fill: rgb(224 15 15); }
            .node rect.module { fill: #8BDEDB; }
            .node rect.operation { fill: #FEBC5A; }
            .edgeLabelGroup {
                pointer-events: none;
            }
            #arrowhead path {
                fill: #333333;;
            }
            .node rect,
            .node ellipse {
                transition: fill 0.3s ease;
            }

            .node .type-indicator {
                font-size: 5px;
                fill: rgba(0, 0, 0, 1.0);  /* Dark grey, semi-transparent */
                pointer-events: none;
            }

            .node.error rect {
                stroke: black;
                stroke-width: 1px;
                /* stroke-dasharray: 3, 3; */
                rx: 5px;
                ry: 5px;
            }

            .boundary-box.error > rect:first-of-type {
                fill: red;
                fill-opacity: 0.2;
            }

            #graph-container {
                position: relative;
            }
            .popup {
                position: absolute;
                background: white;
                border: 1px solid #ccc;
                width: 300px;
                max-height: 400px;
                box-shadow: 0 2px 10px rgba(0,0,0,0.2);
                display: none;
                display: flex;
                flex-direction: column;
            }

            .popup-header {
                position: sticky;
                top: 0;
                background: white;
                padding: 5px 10px;
                border-bottom: 1px solid #ccc;
                display: flex;
                justify-content: space-between;
                align-items: center;
                z-index: 1;
            }

            .popup h3 {
                margin: 0;
                font-size: 16px;
            }

            .popup-content {
                padding: 10px;
                padding-bottom: 10px;
                overflow-y: auto;
                overflow-x: auto;
                flex-grow: 1;
            }

            .popup pre {
                white-space: pre;
                overflow-x: auto;
                font-family: monospace;
            }

            .popup-close {
                cursor: pointer;
                font-size: 24px;
                font-weight: bold;
                line-height: 1;
            }

            #popup-title {
                font-size: 24px;
            }

            #graph-container {
                position: relative;
            }

            pre {
                margin-bottom: 0;
            }

            .boundary-box rect {
                pointer-events: none;
            }
            .boundary-box text {
                pointer-events: none;
                user-select: none;
            }

            .boundary-box rect {
                pointer-events: none;
            }
            .boundary-box text {
                pointer-events: none;
                user-select: none;
                font-weight: bold;
            }
            .edge-label text {
                pointer-events: none;
                user-select: none;
                font-size: 4px;
                font-family: "'Roboto', sans-serif";
            }
            
            .collapse-button:hover {
                fill: #eee;
            }
            .collapse-icon {
                pointer-events: none;
                user-select: none;
                font-family: "'Roboto', sans-serif";
                fill: rgb(51, 51, 51);
            }

            /* Edge hover styles */
            .edge-group path {
              pointer-events: stroke;
            }

            .edge-label {
              pointer-events: all;
            }

            @keyframes containerHighlight {
              0% { 
                filter: drop-shadow(0 0 0px rgba(255, 215, 0, 0));
              }
              25% { 
                filter: drop-shadow(0 0 15px rgba(255, 215, 0, 0.8));
              }
              50% { 
                filter: drop-shadow(0 0 0px rgba(255, 215, 0, 0));
              }
              75% { 
                filter: drop-shadow(0 0 15px rgba(255, 215, 0, 0.8));
              }
              100% { 
                filter: drop-shadow(0 0 0px rgba(255, 215, 0, 0));
              }
            }

            @keyframes containerStrokeHighlight {
              0% { 
                stroke-width: 1px;
              }
              25% { 
                stroke-width: 3px;
              }
              50% { 
                stroke-width: 1px;
              }
              75% { 
                stroke-width: 3px;
              }
              100% { 
                stroke-width: 1px;
              }
            }

            .highlight-cluster > rect:first-of-type {
              animation: 
                         containerStrokeHighlight 2.0s ease-in-out forwards;
            }

            .highlight-node rect {
              animation: 
                         containerStrokeHighlight 2.0s ease-in-out forwards;
            }

            text.node-label {
                font-family: "Roboto", sans-serif;
                font-size: 0.8rem;  /* Base size using rem units for accessibility */
                cursor: default;
                user-select: none;
            }

            .node.constant .node-label {
                font-size: 0.7rem;
            }

        </style>
    </head>
    <body>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.9.0/d3.min.js"></script>
        <script src="https://unpkg.com/@viz-js/viz@3.12.0/lib/viz-standalone.js"></script>
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/atom-one-dark.min.css">
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/python.min.js"></script>
        <script>
(function() {
    document.addEventListener('DOMContentLoaded', (event) => {
        document.querySelectorAll('pre code').forEach((block) => {
            hljs.highlightBlock(block);
        });
    });


    const adj_list = {"input_0": {"edges": [{"target": "Conv2d_1", "dims": "(2, 3, 32, 32)"}], "failed": false, "node_type": "Input"}, "input_1": {"edges": [{"target": "__getitem___4", "dims": "(2, 3, 32, 32)"}], "failed": false, "node_type": "Input"}, "Conv2d_1": {"edges": [{"target": "ReLU_1", "dims": "(2, 32, 32, 32)"}], "failed": false, "node_type": "Module"}, "ReLU_1": {"edges": [{"target": "MaxPool2d_1", "dims": "(2, 32, 32, 32)"}], "failed": false, "node_type": "Module"}, "MaxPool2d_1": {"edges": [{"target": "Conv2d_2", "dims": "(2, 32, 16, 16)"}, {"target": "Conv2d_4", "dims": "(2, 32, 16, 16)"}], "failed": false, "node_type": "Module"}, "Conv2d_2": {"edges": [{"target": "BatchNorm2d_1", "dims": "(2, 64, 8, 8)"}], "failed": false, "node_type": "Module"}, "BatchNorm2d_1": {"edges": [{"target": "ReLU_2", "dims": "(2, 64, 8, 8)"}], "failed": false, "node_type": "Module"}, "ReLU_2": {"edges": [{"target": "Conv2d_3", "dims": "(2, 64, 8, 8)"}], "failed": false, "node_type": "Module"}, "Conv2d_3": {"edges": [{"target": "BatchNorm2d_2", "dims": "(2, 64, 8, 8)"}], "failed": false, "node_type": "Module"}, "BatchNorm2d_2": {"edges": [{"target": "__add___1", "dims": "(2, 64, 8, 8)"}], "failed": false, "node_type": "Module"}, "Conv2d_4": {"edges": [{"target": "BatchNorm2d_3", "dims": "(2, 64, 8, 8)"}], "failed": false, "node_type": "Module"}, "BatchNorm2d_3": {"edges": [{"target": "__add___1", "dims": "(2, 64, 8, 8)"}], "failed": false, "node_type": "Module"}, "__add___1": {"edges": [{"target": "relu_1", "dims": "(2, 64, 8, 8)"}], "failed": false, "node_type": "Operation"}, "relu_1": {"edges": [{"target": "Conv2d_5", "dims": "(2, 64, 8, 8)"}, {"target": "Conv2d_6", "dims": "(2, 64, 8, 8)"}], "failed": false, "node_type": "Operation"}, "Conv2d_5": {"edges": [{"target": "__mul___1", "dims": "(2, 64, 8, 8)"}], "failed": false, "node_type": "Module"}, "__mul___1": {"edges": [{"target": "cat_1", "dims": "(2, 64, 8, 8)"}], "failed": false, "node_type": "Operation"}, "tensor_0": {"edges": [{"target": "__mul___1", "dims": "( )"}], "failed": false, "node_type": "Constant"}, "Conv2d_6": {"edges": [{"target": "ReLU_3", "dims": "(2, 32, 8, 8)"}], "failed": false, "node_type": "Module"}, "ReLU_3": {"edges": [{"target": "Conv2d_7", "dims": "(2, 32, 8, 8)"}], "failed": false, "node_type": "Module"}, "Conv2d_7": {"edges": [{"target": "__mul___2", "dims": "(2, 64, 8, 8)"}], "failed": false, "node_type": "Module"}, "__mul___2": {"edges": [{"target": "cat_1", "dims": "(2, 64, 8, 8)"}], "failed": false, "node_type": "Operation"}, "tensor_1": {"edges": [{"target": "__mul___2", "dims": "( )"}], "failed": false, "node_type": "Constant"}, "cat_1": {"edges": [{"target": "MaxPool2d_2", "dims": "(2, 128, 8, 8)"}], "failed": false, "node_type": "Operation"}, "MaxPool2d_2": {"edges": [{"target": "AdaptiveAvgPool2d_1", "dims": "(2, 128, 4, 4)"}], "failed": false, "node_type": "Module"}, "AdaptiveAvgPool2d_1": {"edges": [{"target": "flatten_1", "dims": "(2, 128, 1, 1)"}], "failed": false, "node_type": "Module"}, "flatten_1": {"edges": [{"target": "Linear_1", "dims": "(2, 128)"}, {"target": "Linear_4", "dims": "(2, 128)"}, {"target": "Linear_5", "dims": "(2, 128)"}, {"target": "Linear_6", "dims": "(2, 128)"}, {"target": "Linear_8", "dims": "(2, 128)"}], "failed": false, "node_type": "Operation"}, "scalar_0": {"edges": [{"target": "flatten_1", "dims": "( )"}], "failed": false, "node_type": "Constant"}, "Linear_1": {"edges": [{"target": "ReLU_4", "dims": "(2, 256)"}], "failed": false, "node_type": "Module"}, "ReLU_4": {"edges": [{"target": "Linear_2", "dims": "(2, 256)"}, {"target": "__mul___3", "dims": "(2, 256)"}], "failed": false, "node_type": "Module"}, "Linear_2": {"edges": [{"target": "ReLU_5", "dims": "(2, 64)"}], "failed": false, "node_type": "Module"}, "ReLU_5": {"edges": [{"target": "Linear_3", "dims": "(2, 64)"}], "failed": false, "node_type": "Module"}, "Linear_3": {"edges": [{"target": "Sigmoid_1", "dims": "(2, 256)"}], "failed": false, "node_type": "Module"}, "Sigmoid_1": {"edges": [{"target": "__mul___3", "dims": "(2, 256)"}], "failed": false, "node_type": "Module"}, "__mul___3": {"edges": [{"target": "__add___2", "dims": "(2, 256)"}], "failed": false, "node_type": "Operation"}, "Linear_4": {"edges": [{"target": "Softmax_1", "dims": "(2, 3)"}], "failed": false, "node_type": "Module"}, "Softmax_1": {"edges": [{"target": "__getitem___1", "dims": "(2, 3)"}, {"target": "__getitem___2", "dims": "(2, 3)"}, {"target": "__getitem___3", "dims": "(2, 3)"}], "failed": false, "node_type": "Module"}, "to_1": {"edges": [{"target": "__iadd___1", "dims": "(2, 256)"}], "failed": false, "node_type": "Operation"}, "tensor_2": {"edges": [{"target": "to_1", "dims": "(2, 256)"}], "failed": false, "node_type": "Constant"}, "Linear_5": {"edges": [{"target": "__mul___4", "dims": "(2, 256)"}], "failed": false, "node_type": "Module"}, "__getitem___1": {"edges": [{"target": "__mul___4", "dims": "(2, 1)"}], "failed": false, "node_type": "Operation"}, "__mul___4": {"edges": [{"target": "__iadd___1", "dims": "(2, 256)"}], "failed": false, "node_type": "Operation"}, "__iadd___1": {"edges": [{"target": "__iadd___2", "dims": "(2, 256)"}], "failed": false, "node_type": "Operation"}, "Linear_6": {"edges": [{"target": "ReLU_6", "dims": "(2, 64)"}], "failed": false, "node_type": "Module"}, "ReLU_6": {"edges": [{"target": "Linear_7", "dims": "(2, 64)"}], "failed": false, "node_type": "Module"}, "Linear_7": {"edges": [{"target": "__mul___5", "dims": "(2, 256)"}], "failed": false, "node_type": "Module"}, "__getitem___2": {"edges": [{"target": "__mul___5", "dims": "(2, 1)"}], "failed": false, "node_type": "Operation"}, "__mul___5": {"edges": [{"target": "__iadd___2", "dims": "(2, 256)"}], "failed": false, "node_type": "Operation"}, "__iadd___2": {"edges": [{"target": "__iadd___3", "dims": "(2, 256)"}], "failed": false, "node_type": "Operation"}, "Linear_8": {"edges": [{"target": "ReLU_7", "dims": "(2, 256)"}], "failed": false, "node_type": "Module"}, "ReLU_7": {"edges": [{"target": "Linear_9", "dims": "(2, 256)"}], "failed": false, "node_type": "Module"}, "Linear_9": {"edges": [{"target": "__mul___6", "dims": "(2, 256)"}], "failed": false, "node_type": "Module"}, "__getitem___3": {"edges": [{"target": "__mul___6", "dims": "(2, 1)"}], "failed": false, "node_type": "Operation"}, "__mul___6": {"edges": [{"target": "__iadd___3", "dims": "(2, 256)"}], "failed": false, "node_type": "Operation"}, "__iadd___3": {"edges": [{"target": "cat_2", "dims": "(2, 256)"}], "failed": false, "node_type": "Operation"}, "__getitem___4": {"edges": [{"target": "__add___2", "dims": "( )"}], "failed": false, "node_type": "Operation"}, "__add___2": {"edges": [{"target": "cat_2", "dims": "(2, 256)"}], "failed": false, "node_type": "Operation"}, "cat_2": {"edges": [{"target": "Linear_10", "dims": "(2, 512)"}], "failed": false, "node_type": "Operation"}, "__add___3": {"edges": [{"target": "__add___4", "dims": "(1)"}], "failed": false, "node_type": "Operation"}, "tensor_3": {"edges": [{"target": "__add___3", "dims": "(1)"}], "failed": false, "node_type": "Constant"}, "tensor_4": {"edges": [{"target": "__add___3", "dims": "(1)"}], "failed": false, "node_type": "Constant"}, "Linear_10": {"edges": [{"target": "__add___4", "dims": "(2, 10)"}], "failed": false, "node_type": "Module"}, "__add___4": {"edges": [{"target": "__add___5", "dims": "(2, 10)"}], "failed": false, "node_type": "Operation"}, "__add___5": {"edges": [{"target": "output_0", "dims": "(2, 10)"}], "failed": false, "node_type": "Operation"}, "scalar_2": {"edges": [{"target": "__add___5", "dims": "( )"}], "failed": false, "node_type": "Constant"}, "output_0": {"edges": [], "failed": false, "node_type": "Output"}};
    const module_info = {"Sequential_1": {"type": "Sequential", "parameters": {}, "attributes": {"call_super_init": false, "dump_patches": false, "training": true}, "extra_repr": ""}, "Conv2d_1": {"type": "Conv2d", "parameters": {"weight": {"shape": [32, 3, 3, 3], "requires_grad": true}, "bias": {"shape": [32], "requires_grad": true}}, "attributes": {"call_super_init": false, "dilation": [1, 1], "dump_patches": false, "groups": 1, "in_channels": 3, "kernel_size": [3, 3], "out_channels": 32, "output_padding": [0, 0], "padding": [1, 1], "padding_mode": "zeros", "stride": [1, 1], "training": true, "transposed": false}, "extra_repr": "3, 32, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1)"}, "ReLU_1": {"type": "ReLU", "parameters": {}, "attributes": {"call_super_init": false, "dump_patches": false, "inplace": true, "training": true}, "extra_repr": "inplace=True"}, "MaxPool2d_1": {"type": "MaxPool2d", "parameters": {}, "attributes": {"call_super_init": false, "ceil_mode": false, "dilation": 1, "dump_patches": false, "kernel_size": 2, "padding": 0, "return_indices": false, "stride": 2, "training": true}, "extra_repr": "kernel_size=2, stride=2, padding=0, dilation=1, ceil_mode=False"}, "ResidualBlock_1": {"type": "ResidualBlock", "parameters": {}, "attributes": {"call_super_init": false, "dump_patches": false, "training": true}, "extra_repr": ""}, "Sequential_2": {"type": "Sequential", "parameters": {}, "attributes": {"call_super_init": false, "dump_patches": false, "training": true}, "extra_repr": ""}, "Conv2d_2": {"type": "Conv2d", "parameters": {"weight": {"shape": [64, 32, 3, 3], "requires_grad": true}}, "attributes": {"call_super_init": false, "dilation": [1, 1], "dump_patches": false, "groups": 1, "in_channels": 32, "kernel_size": [3, 3], "out_channels": 64, "output_padding": [0, 0], "padding": [1, 1], "padding_mode": "zeros", "stride": [2, 2], "training": true, "transposed": false}, "extra_repr": "32, 64, kernel_size=(3, 3), stride=(2, 2), padding=(1, 1), bias=False"}, "BatchNorm2d_1": {"type": "BatchNorm2d", "parameters": {"weight": {"shape": [64], "requires_grad": true}, "bias": {"shape": [64], "requires_grad": true}}, "attributes": {"affine": true, "call_super_init": false, "dump_patches": false, "eps": 1e-05, "momentum": 0.1, "num_features": 64, "track_running_stats": true, "training": true}, "extra_repr": "64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True"}, "ReLU_2": {"type": "ReLU", "parameters": {}, "attributes": {"call_super_init": false, "dump_patches": false, "inplace": true, "training": true}, "extra_repr": "inplace=True"}, "Conv2d_3": {"type": "Conv2d", "parameters": {"weight": {"shape": [64, 64, 3, 3], "requires_grad": true}}, "attributes": {"call_super_init": false, "dilation": [1, 1], "dump_patches": false, "groups": 1, "in_channels": 64, "kernel_size": [3, 3], "out_channels": 64, "output_padding": [0, 0], "padding": [1, 1], "padding_mode": "zeros", "stride": [1, 1], "training": true, "transposed": false}, "extra_repr": "64, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False"}, "BatchNorm2d_2": {"type": "BatchNorm2d", "parameters": {"weight": {"shape": [64], "requires_grad": true}, "bias": {"shape": [64], "requires_grad": true}}, "attributes": {"affine": true, "call_super_init": false, "dump_patches": false, "eps": 1e-05, "momentum": 0.1, "num_features": 64, "track_running_stats": true, "training": true}, "extra_repr": "64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True"}, "Sequential_3": {"type": "Sequential", "parameters": {}, "attributes": {"call_super_init": false, "dump_patches": false, "training": true}, "extra_repr": ""}, "Conv2d_4": {"type": "Conv2d", "parameters": {"weight": {"shape": [64, 32, 1, 1], "requires_grad": true}}, "attributes": {"call_super_init": false, "dilation": [1, 1], "dump_patches": false, "groups": 1, "in_channels": 32, "kernel_size": [1, 1], "out_channels": 64, "output_padding": [0, 0], "padding": [0, 0], "padding_mode": "zeros", "stride": [2, 2], "training": true, "transposed": false}, "extra_repr": "32, 64, kernel_size=(1, 1), stride=(2, 2), bias=False"}, "BatchNorm2d_3": {"type": "BatchNorm2d", "parameters": {"weight": {"shape": [64], "requires_grad": true}, "bias": {"shape": [64], "requires_grad": true}}, "attributes": {"affine": true, "call_super_init": false, "dump_patches": false, "eps": 1e-05, "momentum": 0.1, "num_features": 64, "track_running_stats": true, "training": true}, "extra_repr": "64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True"}, "ParallelPathways_1": {"type": "ParallelPathways", "parameters": {}, "attributes": {"call_super_init": false, "dump_patches": false, "training": true}, "extra_repr": ""}, "Conv2d_5": {"type": "Conv2d", "parameters": {"weight": {"shape": [64, 64, 1, 1], "requires_grad": true}, "bias": {"shape": [64], "requires_grad": true}}, "attributes": {"call_super_init": false, "dilation": [1, 1], "dump_patches": false, "groups": 1, "in_channels": 64, "kernel_size": [1, 1], "out_channels": 64, "output_padding": [0, 0], "padding": [0, 0], "padding_mode": "zeros", "stride": [1, 1], "training": true, "transposed": false}, "extra_repr": "64, 64, kernel_size=(1, 1), stride=(1, 1)"}, "Sequential_4": {"type": "Sequential", "parameters": {}, "attributes": {"call_super_init": false, "dump_patches": false, "training": true}, "extra_repr": ""}, "Conv2d_6": {"type": "Conv2d", "parameters": {"weight": {"shape": [32, 64, 1, 1], "requires_grad": true}, "bias": {"shape": [32], "requires_grad": true}}, "attributes": {"call_super_init": false, "dilation": [1, 1], "dump_patches": false, "groups": 1, "in_channels": 64, "kernel_size": [1, 1], "out_channels": 32, "output_padding": [0, 0], "padding": [0, 0], "padding_mode": "zeros", "stride": [1, 1], "training": true, "transposed": false}, "extra_repr": "64, 32, kernel_size=(1, 1), stride=(1, 1)"}, "ReLU_3": {"type": "ReLU", "parameters": {}, "attributes": {"call_super_init": false, "dump_patches": false, "inplace": false, "training": true}, "extra_repr": ""}, "Conv2d_7": {"type": "Conv2d", "parameters": {"weight": {"shape": [64, 32, 3, 3], "requires_grad": true}, "bias": {"shape": [64], "requires_grad": true}}, "attributes": {"call_super_init": false, "dilation": [1, 1], "dump_patches": false, "groups": 1, "in_channels": 32, "kernel_size": [3, 3], "out_channels": 64, "output_padding": [0, 0], "padding": [1, 1], "padding_mode": "zeros", "stride": [1, 1], "training": true, "transposed": false}, "extra_repr": "32, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1)"}, "MaxPool2d_2": {"type": "MaxPool2d", "parameters": {}, "attributes": {"call_super_init": false, "ceil_mode": false, "dilation": 1, "dump_patches": false, "kernel_size": 2, "padding": 0, "return_indices": false, "stride": 2, "training": true}, "extra_repr": "kernel_size=2, stride=2, padding=0, dilation=1, ceil_mode=False"}, "AdaptiveAvgPool2d_1": {"type": "AdaptiveAvgPool2d", "parameters": {}, "attributes": {"call_super_init": false, "dump_patches": false, "output_size": [1, 1], "training": true}, "extra_repr": "output_size=(1, 1)"}, "Sequential_5": {"type": "Sequential", "parameters": {}, "attributes": {"call_super_init": false, "dump_patches": false, "training": true}, "extra_repr": ""}, "Linear_1": {"type": "Linear", "parameters": {"weight": {"shape": [256, 128], "requires_grad": true}, "bias": {"shape": [256], "requires_grad": true}}, "attributes": {"call_super_init": false, "dump_patches": false, "in_features": 128, "out_features": 256, "training": true}, "extra_repr": "in_features=128, out_features=256, bias=True"}, "ReLU_4": {"type": "ReLU", "parameters": {}, "attributes": {"call_super_init": false, "dump_patches": false, "inplace": false, "training": true}, "extra_repr": ""}, "AttentionModule_1": {"type": "AttentionModule", "parameters": {}, "attributes": {"call_super_init": false, "dump_patches": false, "training": true}, "extra_repr": ""}, "Sequential_6": {"type": "Sequential", "parameters": {}, "attributes": {"call_super_init": false, "dump_patches": false, "training": true}, "extra_repr": ""}, "Linear_2": {"type": "Linear", "parameters": {"weight": {"shape": [64, 256], "requires_grad": true}, "bias": {"shape": [64], "requires_grad": true}}, "attributes": {"call_super_init": false, "dump_patches": false, "in_features": 256, "out_features": 64, "training": true}, "extra_repr": "in_features=256, out_features=64, bias=True"}, "ReLU_5": {"type": "ReLU", "parameters": {}, "attributes": {"call_super_init": false, "dump_patches": false, "inplace": false, "training": true}, "extra_repr": ""}, "Linear_3": {"type": "Linear", "parameters": {"weight": {"shape": [256, 64], "requires_grad": true}, "bias": {"shape": [256], "requires_grad": true}}, "attributes": {"call_super_init": false, "dump_patches": false, "in_features": 64, "out_features": 256, "training": true}, "extra_repr": "in_features=64, out_features=256, bias=True"}, "Sigmoid_1": {"type": "Sigmoid", "parameters": {}, "attributes": {"call_super_init": false, "dump_patches": false, "training": true}, "extra_repr": ""}, "DynamicLayerSelector_1": {"type": "DynamicLayerSelector", "parameters": {}, "attributes": {"call_super_init": false, "dump_patches": false, "training": true}, "extra_repr": ""}, "Sequential_7": {"type": "Sequential", "parameters": {}, "attributes": {"call_super_init": false, "dump_patches": false, "training": true}, "extra_repr": ""}, "Linear_4": {"type": "Linear", "parameters": {"weight": {"shape": [3, 128], "requires_grad": true}, "bias": {"shape": [3], "requires_grad": true}}, "attributes": {"call_super_init": false, "dump_patches": false, "in_features": 128, "out_features": 3, "training": true}, "extra_repr": "in_features=128, out_features=3, bias=True"}, "Softmax_1": {"type": "Softmax", "parameters": {}, "attributes": {"call_super_init": false, "dim": 1, "dump_patches": false, "training": true}, "extra_repr": "dim=1"}, "Linear_5": {"type": "Linear", "parameters": {"weight": {"shape": [256, 128], "requires_grad": true}, "bias": {"shape": [256], "requires_grad": true}}, "attributes": {"call_super_init": false, "dump_patches": false, "in_features": 128, "out_features": 256, "training": true}, "extra_repr": "in_features=128, out_features=256, bias=True"}, "Sequential_8": {"type": "Sequential", "parameters": {}, "attributes": {"call_super_init": false, "dump_patches": false, "training": true}, "extra_repr": ""}, "Linear_6": {"type": "Linear", "parameters": {"weight": {"shape": [64, 128], "requires_grad": true}, "bias": {"shape": [64], "requires_grad": true}}, "attributes": {"call_super_init": false, "dump_patches": false, "in_features": 128, "out_features": 64, "training": true}, "extra_repr": "in_features=128, out_features=64, bias=True"}, "ReLU_6": {"type": "ReLU", "parameters": {}, "attributes": {"call_super_init": false, "dump_patches": false, "inplace": false, "training": true}, "extra_repr": ""}, "Linear_7": {"type": "Linear", "parameters": {"weight": {"shape": [256, 64], "requires_grad": true}, "bias": {"shape": [256], "requires_grad": true}}, "attributes": {"call_super_init": false, "dump_patches": false, "in_features": 64, "out_features": 256, "training": true}, "extra_repr": "in_features=64, out_features=256, bias=True"}, "Sequential_9": {"type": "Sequential", "parameters": {}, "attributes": {"call_super_init": false, "dump_patches": false, "training": true}, "extra_repr": ""}, "Linear_8": {"type": "Linear", "parameters": {"weight": {"shape": [256, 128], "requires_grad": true}, "bias": {"shape": [256], "requires_grad": true}}, "attributes": {"call_super_init": false, "dump_patches": false, "in_features": 128, "out_features": 256, "training": true}, "extra_repr": "in_features=128, out_features=256, bias=True"}, "ReLU_7": {"type": "ReLU", "parameters": {}, "attributes": {"call_super_init": false, "dump_patches": false, "inplace": false, "training": true}, "extra_repr": ""}, "Linear_9": {"type": "Linear", "parameters": {"weight": {"shape": [256, 256], "requires_grad": true}, "bias": {"shape": [256], "requires_grad": true}}, "attributes": {"call_super_init": false, "dump_patches": false, "in_features": 256, "out_features": 256, "training": true}, "extra_repr": "in_features=256, out_features=256, bias=True"}, "Linear_10": {"type": "Linear", "parameters": {"weight": {"shape": [10, 512], "requires_grad": true}, "bias": {"shape": [10], "requires_grad": true}}, "attributes": {"call_super_init": false, "dump_patches": false, "in_features": 512, "out_features": 10, "training": true}, "extra_repr": "in_features=512, out_features=10, bias=True"}};
    const func_info_map = {"Conv2d_1": {"positional_args": ["tensor(2,3,32,32)"], "keyword_args": {}}, "ReLU_1": {"positional_args": ["tensor(2,32,32,32)"], "keyword_args": {}}, "MaxPool2d_1": {"positional_args": ["tensor(2,32,32,32)"], "keyword_args": {}}, "Conv2d_2": {"positional_args": ["tensor(2,32,16,16)"], "keyword_args": {}}, "BatchNorm2d_1": {"positional_args": ["tensor(2,64,8,8)"], "keyword_args": {}}, "ReLU_2": {"positional_args": ["tensor(2,64,8,8)"], "keyword_args": {}}, "Conv2d_3": {"positional_args": ["tensor(2,64,8,8)"], "keyword_args": {}}, "BatchNorm2d_2": {"positional_args": ["tensor(2,64,8,8)"], "keyword_args": {}}, "Conv2d_4": {"positional_args": ["tensor(2,32,16,16)"], "keyword_args": {}}, "BatchNorm2d_3": {"positional_args": ["tensor(2,64,8,8)"], "keyword_args": {}}, "__add___1": {"positional_args": ["tensor(2,64,8,8)", "tensor(2,64,8,8)"], "keyword_args": {}}, "relu_1": {"positional_args": ["tensor(2,64,8,8)"], "keyword_args": {}}, "Conv2d_5": {"positional_args": ["tensor(2,64,8,8)"], "keyword_args": {}}, "__mul___1": {"positional_args": ["tensor()", "tensor(2,64,8,8)"], "keyword_args": {}}, "Conv2d_6": {"positional_args": ["tensor(2,64,8,8)"], "keyword_args": {}}, "ReLU_3": {"positional_args": ["tensor(2,32,8,8)"], "keyword_args": {}}, "Conv2d_7": {"positional_args": ["tensor(2,32,8,8)"], "keyword_args": {}}, "__mul___2": {"positional_args": ["tensor()", "tensor(2,64,8,8)"], "keyword_args": {}}, "cat_1": {"positional_args": ["['tensor(2,64,8,8)', 'tensor(2,64,8,8)']"], "keyword_args": {"dim": 1}}, "MaxPool2d_2": {"positional_args": ["tensor(2,128,8,8)"], "keyword_args": {}}, "AdaptiveAvgPool2d_1": {"positional_args": ["tensor(2,128,4,4)"], "keyword_args": {}}, "flatten_1": {"positional_args": ["tensor(2,128,1,1)", 1], "keyword_args": {}}, "Linear_1": {"positional_args": ["tensor(2,128)"], "keyword_args": {}}, "ReLU_4": {"positional_args": ["tensor(2,256)"], "keyword_args": {}}, "Linear_2": {"positional_args": ["tensor(2,256)"], "keyword_args": {}}, "ReLU_5": {"positional_args": ["tensor(2,64)"], "keyword_args": {}}, "Linear_3": {"positional_args": ["tensor(2,64)"], "keyword_args": {}}, "Sigmoid_1": {"positional_args": ["tensor(2,256)"], "keyword_args": {}}, "__mul___3": {"positional_args": ["tensor(2,256)", "tensor(2,256)"], "keyword_args": {}}, "Linear_4": {"positional_args": ["tensor(2,128)"], "keyword_args": {}}, "Softmax_1": {"positional_args": ["tensor(2,3)"], "keyword_args": {}}, "size_1": {"positional_args": ["tensor(2,128)", 0], "keyword_args": {}}, "to_1": {"positional_args": ["tensor(2,256)", "cpu"], "keyword_args": {}}, "Linear_5": {"positional_args": ["tensor(2,128)"], "keyword_args": {}}, "__getitem___1": {"positional_args": ["tensor(2,3)", "(slice(None, None, None), slice(0, 1, None))"], "keyword_args": {}}, "__mul___4": {"positional_args": ["tensor(2,1)", "tensor(2,256)"], "keyword_args": {}}, "__iadd___1": {"positional_args": ["tensor(2,256)", "tensor(2,256)"], "keyword_args": {}}, "Linear_6": {"positional_args": ["tensor(2,128)"], "keyword_args": {}}, "ReLU_6": {"positional_args": ["tensor(2,64)"], "keyword_args": {}}, "Linear_7": {"positional_args": ["tensor(2,64)"], "keyword_args": {}}, "__getitem___2": {"positional_args": ["tensor(2,3)", "(slice(None, None, None), slice(1, 2, None))"], "keyword_args": {}}, "__mul___5": {"positional_args": ["tensor(2,1)", "tensor(2,256)"], "keyword_args": {}}, "__iadd___2": {"positional_args": ["tensor(2,256)", "tensor(2,256)"], "keyword_args": {}}, "Linear_8": {"positional_args": ["tensor(2,128)"], "keyword_args": {}}, "ReLU_7": {"positional_args": ["tensor(2,256)"], "keyword_args": {}}, "Linear_9": {"positional_args": ["tensor(2,256)"], "keyword_args": {}}, "__getitem___3": {"positional_args": ["tensor(2,3)", "(slice(None, None, None), slice(2, 3, None))"], "keyword_args": {}}, "__mul___6": {"positional_args": ["tensor(2,1)", "tensor(2,256)"], "keyword_args": {}}, "__iadd___3": {"positional_args": ["tensor(2,256)", "tensor(2,256)"], "keyword_args": {}}, "__getitem___4": {"positional_args": ["tensor(2,3,32,32)", "(0, 0, 0, 0)"], "keyword_args": {}}, "__add___2": {"positional_args": ["tensor(2,256)", "tensor()"], "keyword_args": {}}, "cat_2": {"positional_args": ["['tensor(2,256)', 'tensor(2,256)']"], "keyword_args": {"dim": 1}}, "__add___3": {"positional_args": ["tensor(1)", "tensor(1)"], "keyword_args": {}}, "Linear_10": {"positional_args": ["tensor(2,512)"], "keyword_args": {}}, "__add___4": {"positional_args": ["tensor(2,10)", "tensor(1)"], "keyword_args": {}}, "__add___5": {"positional_args": ["tensor(2,10)", 34], "keyword_args": {}}};
    const module_name_to_base_name = {"input_0": "input_0", "input_1": "input_1", "Sequential_1": "Sequential_1", "Conv2d_1": "Conv2d_1", "ReLU_1": "ReLU_1", "MaxPool2d_1": "MaxPool2d_1", "ResidualBlock_1": "ResidualBlock_1", "Sequential_2": "Sequential_2", "Conv2d_2": "Conv2d_2", "BatchNorm2d_1": "BatchNorm2d_1", "ReLU_2": "ReLU_2", "Conv2d_3": "Conv2d_3", "BatchNorm2d_2": "BatchNorm2d_2", "Sequential_3": "Sequential_3", "Conv2d_4": "Conv2d_4", "BatchNorm2d_3": "BatchNorm2d_3", "__add___1": "__add___1", "relu_1": "relu_1", "ParallelPathways_1": "ParallelPathways_1", "Conv2d_5": "Conv2d_5", "__mul___1": "__mul___1", "Sequential_4": "Sequential_4", "Conv2d_6": "Conv2d_6", "ReLU_3": "ReLU_3", "Conv2d_7": "Conv2d_7", "__mul___2": "__mul___2", "cat_1": "cat_1", "MaxPool2d_2": "MaxPool2d_2", "AdaptiveAvgPool2d_1": "AdaptiveAvgPool2d_1", "flatten_1": "flatten_1", "Sequential_5": "Sequential_5", "Linear_1": "Linear_1", "ReLU_4": "ReLU_4", "AttentionModule_1": "AttentionModule_1", "Sequential_6": "Sequential_6", "Linear_2": "Linear_2", "ReLU_5": "ReLU_5", "Linear_3": "Linear_3", "Sigmoid_1": "Sigmoid_1", "__mul___3": "__mul___3", "DynamicLayerSelector_1": "DynamicLayerSelector_1", "Sequential_7": "Sequential_7", "Linear_4": "Linear_4", "Softmax_1": "Softmax_1", "size_1": "size_1", "to_1": "to_1", "Linear_5": "Linear_5", "__getitem___1": "__getitem___1", "__mul___4": "__mul___4", "__iadd___1": "__iadd___1", "Sequential_8": "Sequential_8", "Linear_6": "Linear_6", "ReLU_6": "ReLU_6", "Linear_7": "Linear_7", "__getitem___2": "__getitem___2", "__mul___5": "__mul___5", "__iadd___2": "__iadd___2", "Sequential_9": "Sequential_9", "Linear_8": "Linear_8", "ReLU_7": "ReLU_7", "Linear_9": "Linear_9", "__getitem___3": "__getitem___3", "__mul___6": "__mul___6", "__iadd___3": "__iadd___3", "__getitem___4": "__getitem___4", "__add___2": "__add___2", "cat_2": "cat_2", "__add___3": "__add___3", "Linear_10": "Linear_10", "__add___4": "__add___4", "__add___5": "__add___5", "output_0": "output_0"};
    const parent_module_to_nodes = {"Sequential_1": ["Conv2d_1", "ReLU_1", "MaxPool2d_1", "Conv2d_2", "BatchNorm2d_1", "ReLU_2", "Conv2d_3", "BatchNorm2d_2", "Conv2d_4", "BatchNorm2d_3", "__add___1", "relu_1", "Conv2d_5", "__mul___1", "Conv2d_6", "ReLU_3", "Conv2d_7", "__mul___2", "cat_1", "MaxPool2d_2"], "Sequential_2": ["Conv2d_2", "BatchNorm2d_1", "ReLU_2", "Conv2d_3", "BatchNorm2d_2"], "ResidualBlock_1": ["Conv2d_2", "BatchNorm2d_1", "ReLU_2", "Conv2d_3", "BatchNorm2d_2", "Conv2d_4", "BatchNorm2d_3", "__add___1", "relu_1"], "Sequential_3": ["Conv2d_4", "BatchNorm2d_3"], "ParallelPathways_1": ["Conv2d_5", "__mul___1", "Conv2d_6", "ReLU_3", "Conv2d_7", "__mul___2", "cat_1"], "Sequential_4": ["Conv2d_6", "ReLU_3", "Conv2d_7"], "Sequential_5": ["Linear_1", "ReLU_4", "Linear_2", "ReLU_5", "Linear_3", "Sigmoid_1", "__mul___3"], "Sequential_6": ["Linear_2", "ReLU_5", "Linear_3", "Sigmoid_1"], "AttentionModule_1": ["Linear_2", "ReLU_5", "Linear_3", "Sigmoid_1", "__mul___3"], "Sequential_7": ["Linear_4", "Softmax_1"], "DynamicLayerSelector_1": ["Linear_4", "Softmax_1", "size_1", "to_1", "Linear_5", "__getitem___1", "__mul___4", "__iadd___1", "Linear_6", "ReLU_6", "Linear_7", "__getitem___2", "__mul___5", "__iadd___2", "Linear_8", "ReLU_7", "Linear_9", "__getitem___3", "__mul___6", "__iadd___3"], "Sequential_8": ["Linear_6", "ReLU_6", "Linear_7"], "Sequential_9": ["Linear_8", "ReLU_7", "Linear_9"]};
    const parent_module_to_depth = {"Sequential_1": 3, "Sequential_2": 1, "ResidualBlock_1": 2, "Sequential_3": 1, "ParallelPathways_1": 2, "Sequential_4": 1, "Sequential_5": 3, "Sequential_6": 1, "AttentionModule_1": 2, "Sequential_7": 1, "DynamicLayerSelector_1": 2, "Sequential_8": 1, "Sequential_9": 1};
    const graph_node_name_to_without_suffix = {"input_0": "input_0", "input_1": "input_1", "Conv2d_1": "Conv2d", "ReLU_1": "ReLU", "MaxPool2d_1": "MaxPool2d", "Conv2d_2": "Conv2d", "BatchNorm2d_1": "BatchNorm2d", "ReLU_2": "ReLU", "Conv2d_3": "Conv2d", "BatchNorm2d_2": "BatchNorm2d", "Conv2d_4": "Conv2d", "BatchNorm2d_3": "BatchNorm2d", "__add___1": "__add__", "relu_1": "relu", "Conv2d_5": "Conv2d", "__mul___1": "__mul__", "Conv2d_6": "Conv2d", "ReLU_3": "ReLU", "Conv2d_7": "Conv2d", "__mul___2": "__mul__", "cat_1": "cat", "MaxPool2d_2": "MaxPool2d", "AdaptiveAvgPool2d_1": "AdaptiveAvgPool2d", "flatten_1": "flatten", "Linear_1": "Linear", "ReLU_4": "ReLU", "Linear_2": "Linear", "ReLU_5": "ReLU", "Linear_3": "Linear", "Sigmoid_1": "Sigmoid", "__mul___3": "__mul__", "Linear_4": "Linear", "Softmax_1": "Softmax", "size_1": "size", "to_1": "to", "Linear_5": "Linear", "__getitem___1": "__getitem__", "__mul___4": "__mul__", "__iadd___1": "__iadd__", "Linear_6": "Linear", "ReLU_6": "ReLU", "Linear_7": "Linear", "__getitem___2": "__getitem__", "__mul___5": "__mul__", "__iadd___2": "__iadd__", "Linear_8": "Linear", "ReLU_7": "ReLU", "Linear_9": "Linear", "__getitem___3": "__getitem__", "__mul___6": "__mul__", "__iadd___3": "__iadd__", "__getitem___4": "__getitem__", "__add___2": "__add__", "cat_2": "cat", "__add___3": "__add__", "Linear_10": "Linear", "__add___4": "__add__", "__add___5": "__add__", "output": "output"};
    const ancestor_map = {"Conv2d_1": "Sequential_1", "ReLU_1": "Sequential_1", "MaxPool2d_1": "Sequential_1", "Conv2d_2": "Sequential_2", "Sequential_2": "ResidualBlock_1", "ResidualBlock_1": "Sequential_1", "BatchNorm2d_1": "Sequential_2", "ReLU_2": "Sequential_2", "Conv2d_3": "Sequential_2", "BatchNorm2d_2": "Sequential_2", "Conv2d_4": "Sequential_3", "Sequential_3": "ResidualBlock_1", "BatchNorm2d_3": "Sequential_3", "__add___1": "ResidualBlock_1", "relu_1": "ResidualBlock_1", "Conv2d_5": "ParallelPathways_1", "ParallelPathways_1": "Sequential_1", "tensor_0": "ParallelPathways_1", "__mul___1": "ParallelPathways_1", "Conv2d_6": "Sequential_4", "Sequential_4": "ParallelPathways_1", "ReLU_3": "Sequential_4", "Conv2d_7": "Sequential_4", "tensor_1": "ParallelPathways_1", "__mul___2": "ParallelPathways_1", "cat_1": "ParallelPathways_1", "MaxPool2d_2": "Sequential_1", "Linear_1": "Sequential_5", "ReLU_4": "Sequential_5", "Linear_2": "Sequential_6", "Sequential_6": "AttentionModule_1", "AttentionModule_1": "Sequential_5", "ReLU_5": "Sequential_6", "Linear_3": "Sequential_6", "Sigmoid_1": "Sequential_6", "__mul___3": "AttentionModule_1", "Linear_4": "Sequential_7", "Sequential_7": "DynamicLayerSelector_1", "Softmax_1": "Sequential_7", "tensor_2": "DynamicLayerSelector_1", "to_1": "DynamicLayerSelector_1", "Linear_5": "DynamicLayerSelector_1", "__getitem___1": "DynamicLayerSelector_1", "__mul___4": "DynamicLayerSelector_1", "__iadd___1": "DynamicLayerSelector_1", "Linear_6": "Sequential_8", "Sequential_8": "DynamicLayerSelector_1", "ReLU_6": "Sequential_8", "Linear_7": "Sequential_8", "__getitem___2": "DynamicLayerSelector_1", "__mul___5": "DynamicLayerSelector_1", "__iadd___2": "DynamicLayerSelector_1", "Linear_8": "Sequential_9", "Sequential_9": "DynamicLayerSelector_1", "ReLU_7": "Sequential_9", "Linear_9": "Sequential_9", "__getitem___3": "DynamicLayerSelector_1", "__mul___6": "DynamicLayerSelector_1", "__iadd___3": "DynamicLayerSelector_1"};
    var collapsedContainers = new Set();
    const containerNodes = new Set();
    var adj_list_collapsed_nodes = {};
    let vizInstance = null;

    const EXPAND_TARGET_COVERAGE = 0.8;
    const COLLAPSE_TARGET_COVERAGE = 0.2;
    let lastModifiedContainer = null; // Track the last modified container
    let lastOperation = null; // Track whether it was 'expand' or 'collapse'
    
    function waitForLibs(callback) {
        if (typeof d3 !== 'undefined' && typeof Viz !== 'undefined') {
            Viz.instance().then(viz => {
                vizInstance = viz;
                callback();
            });
        } else {
            setTimeout(function() { waitForLibs(callback) }, 400);
        }
    }

    function extractGraphData(graphData) {
        const result = {
            nodes: {},
            edges: [],
            clusters: {}
        };

        // Process nodes - they have _gvid property and may have a "pos" attribute
        for (const obj of graphData.objects) {
            // Skip cluster objects (which are subgraphs)
            if (obj.name && obj.name.startsWith("cluster_")) {
                result.clusters[obj.name.replace("cluster_", "")] = {
                    bb: obj.bb, // Bounding box "x1,y1,x2,y2"
                    label: obj.label,
                    nodes: obj.nodes ? obj.nodes.map(id => graphData.objects[id].name) : []
                };
                continue;
            }
        
            // This is a node
            if (obj.pos) {
            const [x, y] = obj.pos.split(",").map(Number);
                result.nodes[obj.name] = {
                id: obj._gvid,
                name: obj.name,
                position: { x, y },
                    width: parseFloat(obj.width) * 72, // Convert to pixels (72 points per inch)
                    height: parseFloat(obj.height) * 72,
                    label: obj.label === "\\N" ? obj.name : obj.label
                };
            }
        }

        // Process edges
        for (const edge of graphData.edges) {
            const sourceId = edge.tail;
            const targetId = edge.head;
            
            // Find node names by their _gvid
            const sourceName = Object.values(result.nodes).find(n => n.id === sourceId)?.name;
            const targetName = Object.values(result.nodes).find(n => n.id === targetId)?.name;
            
            if (!sourceName || !targetName) continue;
            
                // Extract path points from the pos attribute
            let pathPoints = [];
            if (edge.pos) {
                // IMPORTANT CHANGE: Correctly handle the "e," prefix
                const posStr = edge.pos;
                // Check if the string starts with "e,"
                if (posStr.startsWith("e,")) {
                    // Split the string and extract coordinates correctly
                    const parts = posStr.split(" ");
                    // Extract the endpoint (first coordinate after "e,")
                    const endPoint = parts[0].substring(2).split(",").map(Number);
                    // Add the remaining points
                    pathPoints = parts.slice(1).map(point => {
                        const [x, y] = point.split(',').map(Number);
                        return { x, y };
                    });
                    
                    // Add the endpoint as the last point in the path
                    pathPoints.push({ x: endPoint[0], y: endPoint[1] });
                } else {
                    // Handle normal path without "e," prefix
                    pathPoints = posStr.split(' ').map(point => {
                    const [x, y] = point.split(',').map(Number);
                    return { x, y };
                    });
                }
            }
        
            result.edges.push({
                source: sourceName,
                target: targetName,
                path: pathPoints
            });
        }

        return result;
    }

    function identifyContainersWithFailedNodes(adj_list, ancestor_map) {
        const failedNodes = Object.keys(adj_list).filter(node => adj_list[node].failed);
      
        const containersWithFailedNodes = new Set();
      
        failedNodes.forEach(failedNode => {
            let currentNode = failedNode;

            while (ancestor_map[currentNode]) {
                const container = ancestor_map[currentNode];
                containersWithFailedNodes.add(container);
                currentNode = container;
            }
        });
      
        return containersWithFailedNodes;
    }


    function generateDotSource(adj_list, ancestor_map) {
        let dotSource = 'digraph G {\n';
        dotSource += '  rankdir=BT;\n'; // Top to bottom layout
        dotSource += '  node [shape=box];\n';

        // Clear and rebuild the containerNodes set
        containerNodes.clear();
        adj_list_collapsed_nodes = {};
        for (const value of Object.values(ancestor_map)) {
            if (value !== null && value !== undefined) {
                containerNodes.add(value);
            }
        }

        // Build container hierarchy
        const containerHierarchy = {};
        for (const [node, parent] of Object.entries(ancestor_map)) {
            if (parent && !containerHierarchy[parent]) {
                containerHierarchy[parent] = [];
            }
            if (parent) {
                containerHierarchy[parent].push(node);
            }
        }

        // Find top containers
        const topContainers = new Set();
        for (const container of containerNodes) {
            // A top container is one that doesn't have an ancestor itself
            if (!ancestor_map[container]) {
                topContainers.add(container);
            }
        }

        // Helper function to get all descendants of a container
        function getAllDescendants(container) {
            let descendants = [];
            const children = containerHierarchy[container] || [];

            for (const child of children) {
                descendants.push(child);
                if (containerNodes.has(child)) {
                    descendants = descendants.concat(getAllDescendants(child));
                }
            }

            return descendants;
        }

        // Process containers
        function processContainer(containerName, level = 0) {
            const indent = ' '.repeat(level * 2);

            // Check if this container is collapsed
            if (collapsedContainers.has(containerName)) {
              // For collapsed containers, create a normal node instead of a subgraph
                dotSource += `${indent}"${containerName}";\n`;
                return;
            }

            // Start subgraph for non-collapsed containers
            dotSource += `${indent}subgraph cluster_${containerName} {\n`;
            dotSource += `${indent}  label="${containerName}";\n`;
            dotSource += `${indent}  style=rounded;\n`;

            // Get all direct children
            const children = containerHierarchy[containerName] || [];

            // Process child containers first
            for (const child of children) {
                if (containerNodes.has(child)) {
                    processContainer(child, level + 1);
                }
            }

            // Add regular nodes
            for (const child of children) {
                if (!containerNodes.has(child)) {
                    if (adj_list[child] && adj_list[child].node_type === "Constant") {
                        dotSource += `${indent}  "${child}" [width=0.7, height=0.3];\n`;
                    } else if (adj_list[child] && (adj_list[child].node_type === "Input" || adj_list[child].node_type === "Output")) {
                        dotSource += `${indent}  "${child}" [width=1.1, height=0.5];\n`;
                    } else {
                        dotSource += `${indent}  "${child}";\n`;
                    }
                }
            }

            // Close subgraph
            dotSource += `${indent}}\n`;
        }

        // Process all top containers
        for (const container of topContainers) {
            processContainer(container);
        }

        // Add standalone nodes (not in containers)
        for (const node of Object.keys(adj_list)) {
            if (!ancestor_map[node]) {
                if (adj_list[node] && adj_list[node].node_type === "Constant") {
                    dotSource += `  "${node}" [width=0.7, height=0.3];\n`;
                } else if (adj_list[node] && (adj_list[node].node_type === "Input" || adj_list[node].node_type === "Output")) {
                    dotSource += `  "${node}" [width=1.1, height=0.5];\n`;
                } else {
                    dotSource += `  "${node}";\n`;
                }
            }
        }

        // Process edges, handling collapsed containers
        for (const [node, data] of Object.entries(adj_list)) {
            for (const edge of data.edges) {
                let sourceNode = node;
                let targetNode = edge.target;
                let dims = edge.dims;
                let skipEdge = false;

                // Check if source node is inside a collapsed container
                for (const collapsedContainer of collapsedContainers) {
                    const descendants = getAllDescendants(collapsedContainer);

                    if (descendants.includes(node)) {
                        // Source node is inside a collapsed container, redirect edge from container
                        sourceNode = collapsedContainer;
                    }

                    if (descendants.includes(edge.target)) {
                        // Target node is inside a collapsed container, redirect edge to container
                        targetNode = collapsedContainer;
                    }

                    // Skip edges between nodes inside the same collapsed container
                    if (descendants.includes(node) && descendants.includes(edge.target)) {
                        skipEdge = true;
                    }
                }

                if (!skipEdge && sourceNode !== targetNode) {
                    dotSource += `  "${sourceNode}" -> "${targetNode}";\n`;
                      if (!(sourceNode in adj_list_collapsed_nodes)) {
                          adj_list_collapsed_nodes[sourceNode] = {'edges': []};
                      }
                      adj_list_collapsed_nodes[sourceNode]['edges'].push({'target': targetNode, 'dims': dims});
                }
            }
        }

        dotSource += '}';
        return dotSource;
    }

        
    function calculateBoundingBox(nodeGroup, nodePositions) {
        let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
        nodeGroup.forEach(nodeName => {
            const node = nodePositions[nodeName];
            if (node) {
                minX = Math.min(minX, node.x - node.width / 2);
                minY = Math.min(minY, node.y - node.height / 2);
                maxX = Math.max(maxX, node.x + node.width / 2);
                maxY = Math.max(maxY, node.y + node.height / 2);
            }
        });
        return { x: minX, y: minY, width: maxX - minX, height: maxY - minY };
    }

    function reloadGraph() {
        d3.select("#graph_631bf51d-fc14-4b88-88b8-067e1293959e").html("");
        const dotSource = generateDotSource(adj_list, ancestor_map);

        graphData = vizInstance.renderJSON(dotSource)
        // Extract the graph data with positions from Graphviz
        const extractedGraphData = extractGraphData(graphData);

        
        // Now create the graph with the Graphviz layout data
        createGraph(extractedGraphData);

        // renderGraphvizImage(dotSource);
    }
                    
    waitForLibs(function() {                                
        reloadGraph();
    });

    function findErrorNode(nodes) {
        return nodes.find(node => adj_list[node].failed);
    }



    // Add this function to render the raw Graphviz visualization
    function renderGraphvizImage(dotSource) {
        // Create a container for the Graphviz image
        const graphvizContainer = d3.select("#graph-container_631bf51d-fc14-4b88-88b8-067e1293959e")
            .append("div")
            .attr("id", "graphviz-image-container")
            .style("margin-top", "20px")
            .style("border-top", "1px solid #ccc")
            .style("padding-top", "20px");
      
        graphvizContainer.append("h3")
            .text("Original Graphviz Rendering")
            .style("text-align", "center");
        
        // Use Viz.js to render the DOT source directly to SVG
        svgElement = vizInstance.renderSVGElement(dotSource)
        // Append the SVG element to the container
        graphvizContainer.node().appendChild(svgElement);
          
        // Style the SVG
        d3.select(svgElement)
            .attr("width", "100%")
            .attr("height", "600px")
            .style("background-color", "#f9f9f9");
        
    }

    function createGraph(graphvizData) {
        const svg = d3.select("#graph_631bf51d-fc14-4b88-88b8-067e1293959e")
        .append("svg")
        .attr("width", "100%")
        .attr("height", "100%")
        .style("background-color", "#f3f3eb");

        const inner = svg.append("g");

        // Add zoom behavior
        const zoom = d3.zoom().on("zoom", function(event) {
            inner.attr("transform", event.transform);
            closePopup();
        });

        svg.call(zoom);

        // Define arrowhead marker
        svg.append("defs").append("marker")
        .attr("id", "arrowhead_631bf51d-fc14-4b88-88b8-067e1293959e")
        .attr("viewBox", "0 -5 10 10")
        .attr("refX", 8)
        .attr("refY", 0)
        .attr("markerWidth", 6)
        .attr("markerHeight", 6)
        .attr("orient", "auto")
        .append("path")
        .attr("d", "M0,-5L10,0L0,5")
        .attr("fill", "#333");

        // Draw clusters (container boxes) first so they're behind nodes
        const clusters = inner.selectAll(".boundary-box")
        .data(Object.entries(graphvizData.clusters))
        .enter()
        .append("g")
        .attr("class", "boundary-box");

        const containersWithFailedNodes = identifyContainersWithFailedNodes(adj_list, ancestor_map);

        clusters.each(function([clusterName, clusterData]) {
            const group = d3.select(this);

            

            const hasFailedNodes = containersWithFailedNodes.has(clusterName);
            if (hasFailedNodes) {
                group.classed("error", true);
            }

            // Parse bounding box coordinates
            const [x1, y1, x2, y2] = clusterData.bb.split(",").map(Number);
            
            // Create boundary box
            group.append("rect")
            .attr("x", x1)
            .attr("y", y1)
            .attr("width", x2 - x1)
            .attr("height", y2 - y1)
            .attr("fill-opacity", 0.0)
            .attr("stroke", "black")
            .attr("stroke-width", 1)
            .attr("rx", 5)
            .attr("ry", 5);
                
            // Create label for the cluster
            const textGroup = group.append("g")
            .attr("transform", `translate(${x1 + 10}, ${y1 + 3})`);
            
            const text = textGroup.append("text")
            .text(clusterData.label)
            .attr("text-anchor", "start")
            .attr("dominant-baseline", "hanging")
            .attr("dy", "-6")
            .attr("font-size", 7)
            .attr("fill", "#333")
            .attr("stroke", "#f3f3eb")
            .attr("stroke-width", "5px")
            .attr("paint-order", "stroke")
            .attr("stroke-linejoin", "round");
                        
            
            // Add collapse/expand button
            group.append("circle")
            .attr("class", "collapse-button")
            .attr("cx", x1 + 10)
            .attr("cy", y1 + 10)
            .attr("r", 6)
            .attr("fill", "#fff")
            .attr("stroke", "#333")
            .attr("stroke-width", 1)
            .attr("cursor", "pointer");
            
            // Add "-" symbol
            group.append("text")
            .attr("class", "collapse-icon")
            .attr("x", x1 + 10)
            .attr("y", y1 + 10)
            .attr("text-anchor", "middle")
            .attr("dominant-baseline", "middle")
            .attr("font-size", "10px")
            .attr("font-weight", "bold")
            .attr("cursor", "pointer")
            .text("—");
        });

        // Add click event handler for collapse buttons
        clusters.selectAll(".collapse-button, .collapse-icon")
        .on("click", function(event, [clusterName, clusterData]) {
            event.stopPropagation(); // Prevent event from bubbling to SVG
            // Collapse the container
            collapsedContainers.add(clusterName);
            
            // Track this container and operation for centering after reload
            lastModifiedContainer = clusterName;
            lastOperation = "collapse";
            reloadGraph();
        });

        
        // Create edges using the path points from Graphviz
        const edges = inner.selectAll(".edge")
        .data(graphvizData.edges)
        .enter()
        .append("g")
        .attr("class", "edge-group");
        
        // Add the actual path
        edges.append("path")
        .attr("class", "edge")
        .attr("d", function(edge) {
            if (edge.path && edge.path.length > 0) {
                    // Create a proper SVG path using Bézier curves
                let d = "";
                const points = edge.path;
                
                    // Start at the first point
                d += `M${points[0].x},${points[0].y}`;
                
                    // Create cubic Bézier curves
                for (let i = 1; i < points.length - 2; i += 3) {
                    if (i + 2 < points.length) {
                        d += ` C${points[i].x},${points[i].y} ${points[i+1].x},${points[i+1].y} ${points[i+2].x},${points[i+2].y}`;
                    }
                }
                
                    // If we have leftover points, draw a line to the last point
                if (points.length % 3 !== 1) {
                    d += ` L${points[points.length-1].x},${points[points.length-1].y}`;
                }
                
                return d;
            }
            return "";
        })
        .attr("marker-end", "url(#arrowhead_631bf51d-fc14-4b88-88b8-067e1293959e)");
        
        // Add dimension labels on edges
        edges.each(function(edge) {
            const edgeGroup = d3.select(this);
            const path = edgeGroup.select("path").node();
            
            if (!path) return;
            
            // Find the source node data
            if (!adj_list[edge.source] && !adj_list_collapsed_nodes[edge.source]) return;
            
            // Find the edge data with matching target
            let sourceNodeData = adj_list_collapsed_nodes[edge.source];
            if (!sourceNodeData) {
                sourceNodeData = adj_list[edge.source];
            }
            const edgeData = sourceNodeData.edges.find(e => e.target === edge.target);
            if (!edgeData || !edgeData.dims) return;
            
            // Calculate position for label - near the start of the edge
            // Get a point that's 20% along the path
            const pathLength = path.getTotalLength();
            const pointAtStart = path.getPointAtLength(pathLength * 0.5);
            
            // Get path direction at that point for text rotation
            const pointBefore = path.getPointAtLength(pathLength * 0.4);
            const pointAfter = path.getPointAtLength(pathLength * 0.6);
            // const angle = Math.atan2(pointAfter.y - pointBefore.y, pointAfter.x - pointBefore.x) * 180 / Math.PI;
            const angle = 0.0;
            
            // Create a background for the text
            const labelGroup = edgeGroup.append("g")
            .attr("class", "edge-label")
            .attr("transform", `translate(${pointAtStart.x}, ${pointAtStart.y})`);
            
            const text = labelGroup.append("text")
            .attr("text-anchor", "middle")
            .attr("dominant-baseline", "central")
            .style("font-size", "5px")
            .text(edgeData.dims)
            .attr("transform", `rotate(${angle})`)
            .attr("stroke", "#f3f3eb")
            .attr("stroke-width", "5px")
            .attr("paint-order", "stroke")
            .attr("stroke-linejoin", "round");

            // Add background rectangle
            const bbox = text.node().getBBox();
            labelGroup.insert("rect", "text")
            .attr("x", bbox.x - 2)
            .attr("y", bbox.y - 2)
            .attr("rx", 4)
            .attr("ry", 4)
            .attr("width", bbox.width + 4)
            .attr("height", bbox.height + 4)
            .attr("fill", "rgb(243, 243, 235) ")
            .attr("fill-opacity", 1.0)
            .attr("transform", `rotate(${angle})`);
        });
        

        // Add hover effects to edge paths
        edges.each(function() {
            const edgeGroup = d3.select(this);
            const path = edgeGroup.select("path");
            const labelGroup = edgeGroup.select(".edge-label");
            const labelText = labelGroup.select("text");
            const labelBg = labelGroup.select("rect");
            const originalStrokeWidth = path.attr("stroke-width") || 1;
            const originalFontSize = labelText.style("font-size") || "5px";
            const originalParent = edgeGroup.node().parentNode;
            const originalPosition = Array.from(originalParent.childNodes).indexOf(edgeGroup.node());
            
            function highlightEdge() {
                // Move to end of parent's children list to appear on top
                originalParent.appendChild(edgeGroup.node());
                
                // Make edge thicker
                path.attr("stroke-width", parseFloat(originalStrokeWidth) * 1.4);
                
                // Make label text larger
                labelText.style("font-size", "7px");
                    
                // Adjust the background rectangle for the label
                const bbox = labelText.node().getBBox();
                labelBg.attr("x", bbox.x - 2)
                    .attr("y", bbox.y - 2)
                    .attr("width", bbox.width + 4)
                    .attr("height", bbox.height + 4);
            }
            
            function resetEdge() {
                // Restore original position in parent's children list
                const currentIndex = Array.from(originalParent.childNodes).indexOf(edgeGroup.node());
                if (currentIndex !== originalPosition) {
                    // Insert back at original position
                    const referenceNode = originalParent.childNodes[originalPosition] || null;
                    originalParent.insertBefore(edgeGroup.node(), referenceNode);
                }
                
                // Restore original edge thickness
                path.attr("stroke-width", originalStrokeWidth);
                
                // Restore original label text size
                labelText.style("font-size", originalFontSize);
                    
                // Restore original background rectangle size
                const bbox = labelText.node().getBBox();
                labelBg.attr("x", bbox.x - 2)
                    .attr("y", bbox.y - 2)
                    .attr("width", bbox.width + 4)
                    .attr("height", bbox.height + 4);
            }
            
            // Add hover events to the path
            path.on("mouseenter", highlightEdge)
                .on("mouseleave", resetEdge);
            
            // Add hover events to label group (both text and background)
            if (labelGroup.node()) {
                labelText.on("mouseenter", highlightEdge)
                    .on("mouseleave", resetEdge);
                    
                labelBg.on("mouseenter", highlightEdge)
                    .on("mouseleave", resetEdge);
            }
        });


        // Create nodes using positions from Graphviz
        const nodes = inner.selectAll(".node")
            .data(Object.entries(graphvizData.nodes))
            .enter()
            .append("g")
            // In the createGraph function, when you're creating nodes, modify the class assignment:
            .attr("class", function([nodeName, nodeData]) {
                let classes = "node";
                if ((adj_list[nodeName] && adj_list[nodeName].failed) || containersWithFailedNodes.has(nodeName)) classes += " error";
                if ((adj_list[nodeName] && adj_list[nodeName].node_type === "Input")) classes += " input";
                else if ((adj_list[nodeName] && adj_list[nodeName].node_type === "Module") || (collapsedContainers.has(nodeName))) classes += " module";
                else if ((adj_list[nodeName] && adj_list[nodeName].node_type === "Output")) classes += " output";
                else if ((adj_list[nodeName] && adj_list[nodeName].node_type === "Operation")) classes += " operation";
                else if ((adj_list[nodeName] && adj_list[nodeName].node_type === "Constant")) classes += " constant";
                return classes;
            })
            .attr("transform", function([nodeName, nodeData]) {
                return `translate(${nodeData.position.x}, ${nodeData.position.y})`;
            });
        
        // Filter nodes for click event - don't include input or output nodes
        inner.selectAll(".node")
            .filter(function([nodeName]) {
                return !(((adj_list[nodeName] && adj_list[nodeName].node_type === "Output")) || ((adj_list[nodeName] && adj_list[nodeName].node_type === "Input")) || ((adj_list[nodeName] && adj_list[nodeName].node_type === "Constant"))) && !collapsedContainers.has(nodeName)
            })
            .on("click", showPopup);

        
        // Add rectangles for nodes
        nodes.append("rect")
        .attr("width", function([nodeName, nodeData]) { return nodeData.width; })
        .attr("height", function([nodeName, nodeData]) { return nodeData.height; })
        .attr("x", function([nodeName, nodeData]) { return -nodeData.width / 2; })
        .attr("y", function([nodeName, nodeData]) { return -nodeData.height / 2; })
        .attr("class", function([nodeName]) { 
            if (adj_list[nodeName] && adj_list[nodeName].node_type === "Input") return "input";
            if (adj_list[nodeName] && adj_list[nodeName].node_type === "Output") return "output";
            if (adj_list[nodeName] && adj_list[nodeName].node_type === "Constant") return "constant";
            if ((adj_list[nodeName] && adj_list[nodeName].failed) || containersWithFailedNodes.has(nodeName)) return "failed";
            return ((adj_list[nodeName] && adj_list[nodeName].node_type === "Module") || (collapsedContainers.has(nodeName))) ? "module" : "operation";
        });
        
        // Add labels for nodes
        nodes.append("text")
        .attr("class", "node-label")
        .text(function([nodeName]) { return graph_node_name_to_without_suffix[nodeName] || nodeName; })
        .attr("text-anchor", "middle")
        .attr("dominant-baseline", "central");
        
        // Add type indicators
        nodes.filter(function([nodeName]) {
            return !(((adj_list[nodeName] && adj_list[nodeName].node_type === "Output")) || ((adj_list[nodeName] && adj_list[nodeName].node_type === "Input")) || ((adj_list[nodeName] && adj_list[nodeName].node_type === "Constant")));
        }).append("text")
        .attr("class", "type-indicator")
        .attr("text-anchor", "end")
        .attr("dominant-baseline", "hanging")
        .attr("transform", function([nodeName, nodeData]) {
            return `translate(${nodeData.width / 2 - 3}, ${-nodeData.height / 2 + 3})`;
        })
        .text(function([nodeName]) {
            return (adj_list[nodeName] && adj_list[nodeName].node_type === "Module") || (collapsedContainers.has(nodeName)) ? "Module" : "Tensor Op";
        });

        // Add collapse/expand buttons to collapsed container nodes
        inner.selectAll(".node")
        .filter(function([nodeName]) {
            return collapsedContainers.has(nodeName);
        })
        .each(function([nodeName, nodeData]) {
            const nodeGroup = d3.select(this);
            const width = nodeData.width;
            const height = nodeData.height;        
            // Add collapse/expand button (with "+" since it's collapsed)
            nodeGroup.append("circle")
            .attr("class", "collapse-button")
            .attr("cx", -width/2 + 8)
            .attr("cy", -height/2 + 8)
            .attr("r", 6)
            .attr("fill", "#fff")
            .attr("stroke", "#333")
            .attr("stroke-width", 1)
            .attr("cursor", "pointer");
        
            // Add "+" symbol
            nodeGroup.append("text")
            .attr("class", "collapse-icon")
            .attr("x", -width/2 + 8)
            .attr("y", -height/2 + 8) 
            .attr("text-anchor", "middle")
            .attr("dominant-baseline", "middle")
            .attr("font-size", "10px")
            .attr("font-weight", "bold")
            .attr("cursor", "pointer")
            .text("+");
            
            // Add click handler using the existing reloadGraph function
            nodeGroup.selectAll(".collapse-button, .collapse-icon")
            .on("click", function(event) {
                event.stopPropagation();
                
                // Always expanding when clicked (since these are collapsed containers)
                collapsedContainers.delete(nodeName);

                // Track this container and operation for centering after reload
                lastModifiedContainer = nodeName;
                lastOperation = "expand";
                
                // Use the existing reloadGraph function
                reloadGraph();
            });
        });    

        // Add hover effects
        nodes.each(function() {
            const nodeGroup = d3.select(this);
            const rect = nodeGroup.select("rect");
            const originalColor = rect.style("fill");
            let isHovered = false;
            
            nodeGroup.on("mouseenter", function() {
                if (!isHovered) {
                    isHovered = true;
                    const currentColor = d3.color(rect.style("fill") || originalColor);
                    rect.style("fill", currentColor.brighter(0.4));
                }
            })
            .on("mouseleave", function() {
                isHovered = false;
                rect.style("fill", originalColor);
            });
        });
        
        
        // Implement popup functionality
        function showPopup(event, [nodeName]) {
            event.stopPropagation();
            
            const popup = d3.select("#popup_631bf51d-fc14-4b88-88b8-067e1293959e");
            const clickedElement = d3.select(this).select("rect").node();
            const moduleTemplate = d3.select("#module-template_631bf51d-fc14-4b88-88b8-067e1293959e");
            const tensorOpTemplate = d3.select("#tensor-op-template_631bf51d-fc14-4b88-88b8-067e1293959e");
            const noInfoMessage = d3.select("#no-info_631bf51d-fc14-4b88-88b8-067e1293959e");
            
            const nodeData = adj_list[nodeName];
            
            d3.select("#popup-title_631bf51d-fc14-4b88-88b8-067e1293959e").text(graph_node_name_to_without_suffix[nodeName] || nodeName);
            
            // d3.select("#input-dims_631bf51d-fc14-4b88-88b8-067e1293959e").text(nodeData.input_dims);
            // d3.select("#output-dims_631bf51d-fc14-4b88-88b8-067e1293959e").text(nodeData.output_dims);
            
            moduleTemplate.style("display", "none");
            tensorOpTemplate.style("display", "none");
            noInfoMessage.style("display", "none");
            
            if (((adj_list[nodeName] && adj_list[nodeName].node_type === "Module")) && (module_info[nodeName] || (module_name_to_base_name[nodeName] && module_info[module_name_to_base_name[nodeName]]))) {
                const info = module_info[nodeName] ? module_info[nodeName] : module_info[module_name_to_base_name[nodeName]];
                moduleTemplate.style("display", "block").classed("content-shown", true);
                
                d3.select("#module-type_631bf51d-fc14-4b88-88b8-067e1293959e").text(info.type || 'N/A');
                d3.select("#module-attributes_631bf51d-fc14-4b88-88b8-067e1293959e").text(JSON.stringify(info.attributes, null, 2));
                d3.select("#module-parameters_631bf51d-fc14-4b88-88b8-067e1293959e").text(JSON.stringify(info.parameters, null, 2));
                d3.select("#module-extra-repr_631bf51d-fc14-4b88-88b8-067e1293959e").text(info.extra_repr || 'N/A');
            } else if (!(adj_list[nodeName] && adj_list[nodeName].node_type === "Input") && func_info_map[nodeName]) {
                const info = func_info_map[nodeName];
                tensorOpTemplate.style("display", "block").classed("content-shown", true);
                
                d3.select("#tensor-parameters_631bf51d-fc14-4b88-88b8-067e1293959e").text(JSON.stringify(info, null, 2));
            } else {
                noInfoMessage.style("display", "block").classed("content-shown", true);
            }
            
            const boundingBox = clickedElement.getBoundingClientRect();
            const containerRect = d3.select("#graph-container_631bf51d-fc14-4b88-88b8-067e1293959e").node().getBoundingClientRect();
            
            const x = boundingBox.left + boundingBox.width / 2 - containerRect.left;
            const y = boundingBox.top + boundingBox.height / 2 - containerRect.top;
            
            popup.style("left", `${x}px`)
            .style("top", `${y}px`)
            .style("display", "flex");
            d3.select("#popup-content_631bf51d-fc14-4b88-88b8-067e1293959e").node().scrollTop = 0;
        }
        
        function closePopup() {
            d3.select("#popup_631bf51d-fc14-4b88-88b8-067e1293959e").style("display", "none");
        }
        
        d3.select(".popup-close").on("click", closePopup);
        svg.on("click", closePopup);
        
        // Calculate view box to ensure the graph is properly scaled and centered
        const findErrorNode = (nodes) => {
            for (const [nodeName] of nodes) {
                if (adj_list[nodeName] && adj_list[nodeName].failed) {
                    return nodeName;
                }
            }
            return null;
        };
        
        const errorNode = findErrorNode(Object.entries(graphvizData.nodes));
        
        // Initial zoom setup
        const svgNode = svg.node();
        const width = svgNode.clientWidth || 800; // Fallback if clientWidth is 0
        const height = svgNode.clientHeight || 600; // Fallback if clientHeight is 0
        
        if (lastModifiedContainer && (Object.keys(graphvizData.nodes).includes(lastModifiedContainer) || 
            Object.keys(graphvizData.clusters).includes(lastModifiedContainer))) {
            
            // Center on the container that was just expanded or collapsed
            let targetCoverage = lastOperation === "expand" ? EXPAND_TARGET_COVERAGE : COLLAPSE_TARGET_COVERAGE;
            let targetNode;
            let targetPos;
            let containerWidth, containerHeight;
            
            if (Object.keys(graphvizData.nodes).includes(lastModifiedContainer)) {
                // It's a node (collapsed container)
                targetNode = graphvizData.nodes[lastModifiedContainer];
                targetPos = { x: targetNode.position.x, y: targetNode.position.y };
                containerWidth = targetNode.width;
                containerHeight = targetNode.height;
            } else if (Object.keys(graphvizData.clusters).includes(lastModifiedContainer)) {
                // It's a cluster (expanded container)
                const clusterData = graphvizData.clusters[lastModifiedContainer];
                const [x1, y1, x2, y2] = clusterData.bb.split(",").map(Number);
                targetPos = { x: (x1 + x2) / 2, y: (y1 + y2) / 2 };
                containerWidth = x2 - x1;
                containerHeight = y2 - y1;
            }
            
            if (targetPos && containerWidth && containerHeight) {
                // Calculate scale to make container occupy the target percentage of viewport
                const widthScale = (width * targetCoverage) / containerWidth;
                const heightScale = (height * targetCoverage) / containerHeight;
                // Use the smaller scale to ensure container fits in viewport
                const targetScale = Math.min(widthScale, heightScale);
                
                const translate = [
                    width / 2 - targetPos.x * targetScale,
                    height / 2 - targetPos.y * targetScale
                ];
                
                svg.call(zoom.transform, d3.zoomIdentity
                    .translate(translate[0], translate[1])
                    .scale(targetScale));
                
                // Apply highlight effect to the target container
                if (Object.keys(graphvizData.nodes).includes(lastModifiedContainer)) {
                    // Highlight the node (collapsed container)
                    const targetElement = inner.selectAll(".node")
                        .filter(([nodeName]) => nodeName === lastModifiedContainer);
                        
                    if (!targetElement.empty()) {
                        targetElement.classed("highlight-node", true);
                        
                        // Remove the highlight class after animation completes
                        setTimeout(() => {
                            targetElement.classed("highlight-node", false);
                        }, 2000); // Match the animation duration
                    }
                } else if (Object.keys(graphvizData.clusters).includes(lastModifiedContainer)) {
                    // Highlight the cluster (expanded container)
                    const targetElement = inner.selectAll(".boundary-box")
                        .filter(function([clusterName]) {
                            return clusterName === lastModifiedContainer;
                        });
                        
                    if (!targetElement.empty()) {
                        targetElement.classed("highlight-cluster", true);
                        
                        // Remove the highlight class after animation completes
                        setTimeout(() => {
                            targetElement.classed("highlight-cluster", false);
                        }, 2000); // Match the animation duration
                    }
                }
                
                // Reset tracking variables after applying the transformation
                lastModifiedContainer = null;
                lastOperation = null;
            }
        } else if (errorNode) {
            // Focus on the error node if there is one
            const nodeData = graphvizData.nodes[errorNode];
            if (nodeData) {
                const scale = 2; // Zoom in on error node
                const translate = [
                    width / 2 - nodeData.position.x * scale,
                    height / 2 - nodeData.position.y * scale
                    ];
                
                svg.call(zoom.transform, d3.zoomIdentity
                    .translate(translate[0], translate[1])
                    .scale(scale));
            }
        } else {
            // Show the entire graph
            // Find the bounds of the graph
            let minX = Infinity, minY = Infinity;
            let maxX = -Infinity, maxY = -Infinity;
            
            Object.values(graphvizData.nodes).forEach(node => {
                minX = Math.min(minX, node.position.x - node.width / 2);
                minY = Math.min(minY, node.position.y - node.height / 2);
                maxX = Math.max(maxX, node.position.x + node.width / 2);
                maxY = Math.max(maxY, node.position.y + node.height / 2);
            });
            
            // Also consider cluster bounding boxes
            Object.values(graphvizData.clusters).forEach(cluster => {
                const [x1, y1, x2, y2] = cluster.bb.split(",").map(Number);
                minX = Math.min(minX, x1);
                minY = Math.min(minY, y1);
                maxX = Math.max(maxX, x2);
                maxY = Math.max(maxY, y2);
            });
            
            const graphWidth = maxX - minX;
            const graphHeight = maxY - minY;
            
            // Determine scale to fit the entire graph with some padding
            const scale = Math.min(width / graphWidth, height / graphHeight) * 0.9;
            
            // Center the graph
            const translate = [
                width / 2 - (minX + graphWidth / 2) * scale,
                height / 2 - (minY + graphHeight / 2) * scale
                ];
            
            svg.call(zoom.transform, d3.zoomIdentity
                .translate(translate[0], translate[1])
                .scale(scale));
        }
            
    }
})();
        </script>

        <div class="container">
            <div class="left-column">

<div class="code-box" id="codeBox">
    <div class="code-box-header">Sample code (Not editable)</div>
    <pre><code class="language-python">
import torch
import torch.nn as nn
import torch.nn.functional as F
from torchvista import trace_model


class ResidualBlock(nn.Module):
    def __init__(self, in_channels, out_channels, stride=1):
        super(ResidualBlock, self).__init__()
        self.conv_block = nn.Sequential(
            nn.Conv2d(in_channels, out_channels, kernel_size=3, stride=stride, padding=1, bias=False),
            nn.BatchNorm2d(out_channels),
            nn.ReLU(inplace=True),
            nn.Conv2d(out_channels, out_channels, kernel_size=3, stride=1, padding=1, bias=False),
            nn.BatchNorm2d(out_channels)
        )
        
        self.shortcut = nn.Identity()
        if stride != 1 or in_channels != out_channels:
            self.shortcut = nn.Sequential(
                nn.Conv2d(in_channels, out_channels, kernel_size=1, stride=stride, bias=False),
                nn.BatchNorm2d(out_channels)
            )
    
    def forward(self, x):
        return F.relu(self.conv_block(x) + self.shortcut(x))


class AttentionModule(nn.Module):
    def __init__(self, in_features):
        super(AttentionModule, self).__init__()
        self.attention = nn.Sequential(
            nn.Linear(in_features, in_features // 4),
            nn.ReLU(),
            nn.Linear(in_features // 4, in_features),
            nn.Sigmoid()
        )
        
    def forward(self, x):
        # x shape: [batch_size, in_features]
        attention_weights = self.attention(x)
        return x * attention_weights


class ParallelPathways(nn.Module):
    def __init__(self, in_channels, out_channels):
        super(ParallelPathways, self).__init__()
        
        # Using ModuleDict to store different pathways
        self.pathways = nn.ModuleDict({
            'path1': nn.Conv2d(in_channels, out_channels // 2, kernel_size=1),
            'path2': nn.Sequential(
                nn.Conv2d(in_channels, in_channels // 2, kernel_size=1),
                nn.ReLU(),
                nn.Conv2d(in_channels // 2, out_channels // 2, kernel_size=3, padding=1)
            )
        })
        
        # Using ParameterDict for learnable weights
        self.weights = nn.ParameterDict({
            'path1_weight': nn.Parameter(torch.tensor(0.5)),
            'path2_weight': nn.Parameter(torch.tensor(0.5))
        })
    
    def forward(self, x):
        outputs = [
            self.weights['path1_weight'] * self.pathways['path1'](x),
            self.weights['path2_weight'] * self.pathways['path2'](x)
        ]
        return torch.cat(outputs, dim=1)


class DynamicLayerSelector(nn.Module):
    def __init__(self, in_features, out_features):
        super(DynamicLayerSelector, self).__init__()
        
        # Using ModuleList to store different layer types
        self.layers = nn.ModuleList([
            nn.Linear(in_features, out_features),
            nn.Sequential(
                nn.Linear(in_features, in_features // 2),
                nn.ReLU(),
                nn.Linear(in_features // 2, out_features)
            ),
            nn.Sequential(
                nn.Linear(in_features, in_features * 2),
                nn.ReLU(),
                nn.Linear(in_features * 2, out_features)
            )
        ])
        
        # Selector network
        self.selector = nn.Sequential(
            nn.Linear(in_features, 3),
            nn.Softmax(dim=1)
        )
    
    def forward(self, x):
        # Get weights for each layer
        weights = self.selector(x)
        
        # Apply each layer and weight its output
        results = torch.zeros(x.size(0), self.layers[0].out_features).to(x.device)
        for i, layer in enumerate(self.layers):
            layer_output = layer(x)
            results += weights[:, i:i+1] * layer_output
            # results += weights[:, i:i+2] * layer_output
        
        return results


class ComplexModel(nn.Module):
    def __init__(self):
        super(ComplexModel, self).__init__()
        
        # Feature extraction layers
        self.features = nn.Sequential(
            nn.Conv2d(3, 32, kernel_size=3, stride=1, padding=1),
            nn.ReLU(inplace=True),
            nn.MaxPool2d(kernel_size=2, stride=2),
            ResidualBlock(32, 64, stride=2),
            ParallelPathways(64, 128),
            nn.MaxPool2d(kernel_size=2, stride=2)
        )
        
        # Adaptive pooling to get fixed size regardless of input
        self.adaptive_pool = nn.AdaptiveAvgPool2d((1, 1))
        
        # Classifier with multiple paths
        self.classifier_paths = nn.ModuleDict({
            'main': nn.Sequential(
                nn.Linear(128, 256),
                nn.ReLU(),
                AttentionModule(256)
            ),
            'auxiliary': DynamicLayerSelector(128, 256)
        })
        
        # Final classification layer
        self.final_classifier = nn.Linear(256 * 2, 10)
        
        # Parameter lists for demonstration
        self.aux_biases = nn.ParameterList([
            nn.Parameter(torch.randn(1)),
            nn.Parameter(torch.randn(1))
        ])
    
    def forward(self, x, y):
        # Input shape: [batch_size, 3, height, width]
        x = self.features(x)
        x = self.adaptive_pool(x)
        x = torch.flatten(x, 1)
        
        # Process through parallel classifier paths
        main_features = self.classifier_paths['main'](x)
        aux_features = self.classifier_paths['auxiliary'](x)
        
        # Concatenate features from different paths
        combined = torch.cat([main_features + y[0, 0, 0, 0], aux_features], dim=1)
        
        # Add auxiliary biases for demonstration
        bias = self.aux_biases[0] + self.aux_biases[1]
        
        # Final classification
        return self.final_classifier(combined) + bias + 34

model = ComplexModel()
x = torch.randn(2, 3, 32, 32)
y = torch.randn(2, 3, 32, 32)

example_input = (x, y)

trace_model(model, example_input)

</code></pre>
</div>

<div class="error-box" id="errorBox">
    <div class="error-box-header">Error Output (if any)</div>

</div>

            </div>
    
            <div class="graph-view" id="graphContainer" style="height: 100%">
                <div class="graph-box-header">Visualized Interactive Graph</div>
                <div id="graph-container_631bf51d-fc14-4b88-88b8-067e1293959e" style="height: 97%; overflow: auto; position: relative;">
                    <div id="graph_631bf51d-fc14-4b88-88b8-067e1293959e" style="height: 100%"></div>
                    <div id="popup_631bf51d-fc14-4b88-88b8-067e1293959e" class="popup" style="display: none;">
                        <div class="popup-header">
                            <h3 id="popup-title_631bf51d-fc14-4b88-88b8-067e1293959e"></h3>
                            <span class="popup-close">✕</span>
                        </div>
                        <div id="popup-content_631bf51d-fc14-4b88-88b8-067e1293959e" class="popup-content">
                            <div id="common-info_631bf51d-fc14-4b88-88b8-067e1293959e">
                            </div>
                            <div id="module-template_631bf51d-fc14-4b88-88b8-067e1293959e" style="display:none;">
                                <p><strong>Type:</strong> <span id="module-type_631bf51d-fc14-4b88-88b8-067e1293959e"></span></p>
                                <p><strong>Attributes:</strong></p>
                                <pre id="module-attributes_631bf51d-fc14-4b88-88b8-067e1293959e"></pre>
                                <p><strong>Parameters:</strong></p>
                                <pre id="module-parameters_631bf51d-fc14-4b88-88b8-067e1293959e"></pre>
                                <p><strong>Extra Repr:</strong></p>
                                <pre id="module-extra-repr_631bf51d-fc14-4b88-88b8-067e1293959e"></pre>
                            </div>
                            <div id="tensor-op-template_631bf51d-fc14-4b88-88b8-067e1293959e" style="display:none;">
                                <p><strong>Parameters:</strong></p>
                                <pre id="tensor-parameters_631bf51d-fc14-4b88-88b8-067e1293959e"></pre>
                            </div>
                            <p id="no-info_631bf51d-fc14-4b88-88b8-067e1293959e" style="display:none;">No further information available for this node.</p>
                        </div>
                    </div>
                    <div id="popup-content_631bf51d-fc14-4b88-88b8-067e1293959e"></div>
                </div>
            </div>
        </div>
    </body>
</html>
